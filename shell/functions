#!/usr/bin/env sh
# @TODO gpg keys,tmux
export SHELL_FUNC_PATH=$(realpath "${BASH_SOURCE:-$0}")
SSH_USER_DIR="$HOME/.ssh"
SSH_CONFD_DIR="$SSH_USER_DIR/conf.d"
SSH_CONFIG="
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
#
#
# The SSH client reads the configuration file stanza by stanza, and if more than one patterns match,
# the options from the first matching stanza take precedence. Therefore more host-specific declarations
# should be given at the beginning of the file, and more general overrides at the end of the file.
#
# Man page: https://man.openbsd.org/OpenBSD-current/man5/ssh_config.5

Include $SSH_CONFD_DIR/*.conf
Host *
  TCPKeepAlive yes
  ServerAliveInterval 120
  User root
  Compression yes
"
BOOKMARKS_DIR="$HOME/.bookmarks"
KUBE_CLUSTERS_DIR="$HOME/.kube/clusters"
AWS_CREDENTIALS_PATH="$HOME/.aws/credentials"

# Yes/No prompt to confirm any action. Returns 0 or 1
# call syntax: _confirm [<prompt>]
_confirm() {
    local prompt result response
    [ ! -z "$1" ] && prompt="$1" || prompt="Are you sure"
    prompt="$prompt [y/n] ?"
    # Loop forever until the user enters a valid response (Y/N or Yes/No).
    while true; do
        read -r -p "$prompt " response
        case "$response" in
            [Yy][Ee][Ss] | [Yy]) # Yes or Y (case-insensitive).
                result=0
                break
                ;;
            [Nn][Oo] | [Nn]) # No or N.
                result=1
                break
                ;;
            *) # Anything else (including a blank) is invalid.
                ;;
        esac
    done
    echo $result
}

###DOC: funclist - List defined shell functions
funclist() {
    awk '{ if ($1 ~ /^###DOC:/) print $0 }' $SHELL_FUNC_PATH | sed 's/###DOC: //'
}

###DOC: findup - find in parent directories, uses "find". Example findup -name ".venv" -type d
findup() {
    local path=$(pwd)
    local result
    while [[ "$path" != / ]]; do
        result=$(find "$path" -maxdepth 1 -mindepth 1 "$@")
        path="$(readlink -f "$path"/..)"
        if [ -n "$result" ]; then
            echo $result
            return
        fi
    done
}

###DOC: fdup - find in parent directories, uses "fd". Example fdup -g ".venv" -t d
fdup() {
    local path=$(pwd)
    local result
    while [[ "$path" != / ]]; do
        result=$(fd --exact-depth=1 -H --no-ignore --absolute-path "$@" "$path")
        path="$(readlink -f "$path"/..)"
        if [ -n "$result" ]; then
            echo $result
            return
        fi
    done
}

# SSH tools

# Print info of given ssh host
_ssh_info() {
    [ -z "$1" ] && return || true
    host_info=$(ssh -tt -G $1)
    agent_info=$(ssh-add -l)
    echo "$host_info" | grep hostname | head -n 1
    echo "$host_info" | grep user | head -n 1
    echo "$host_info" | grep port | head -n 1
    echo "$host_info" | grep identityfile | head -n 1
    echo "$host_info" | grep localforward
    echo -e "\n[ SSH agent keys: ]"
    echo "$agent_info"
}
# another way to make visible in fzf preview _ssh_info
# export -f _ssh_info

# Init sshlist directory structure and files
_ssh_init() {
    local overwrite_bak overwrite_conf
    mkdir -p $SSH_CONFD_DIR
    [ -f "$SSH_USER_DIR/known_hosts" ] && true || touch "$SSH_USER_DIR/known_hosts"
    # when ssh config already exists
    if [ -f "$SSH_USER_DIR/config" ]; then
        overwrite_conf=$(_confirm "$SSH_USER_DIR/config already exists. This file will be backed up and replaced. Continue?")
        [ $overwrite_conf -eq 1 ] && return || true
        # when bak file already exists
        if [ -f "$SSH_USER_DIR/config.bak" ]; then
            overwrite_bak=$(_confirm "$SSH_USER_DIR/config.bak already exists, overwrite?")
            if [ $overwrite_bak -eq 0 ]; then
                mv -f "$SSH_USER_DIR/config" "$SSH_USER_DIR/config.bak"
            fi
        else
            mv -f "$SSH_USER_DIR/config" "$SSH_USER_DIR/config.bak"
        fi
    fi
    echo "$SSH_CONFIG" > "$SSH_USER_DIR/config"
    echo "sshlist initialized"
    return 0
}

# Check sshlist directories and files
_ssh_check() {
    local noexist_error empty_dir_error
    noexist_error="doesn't exist. Run 'sshlist init' first."
    empty_dir_error="$SSH_CONFD_DIR is empty. Add files first."
    [ ! -d "$SSH_CONFD_DIR" ] && echo "$SSH_CONFD_DIR $noexist_error" && return 1 || true
    [ ! -f "$SSH_USER_DIR/config" ] && echo "$SSH_USER_DIR/config $noexist_error" && return 1 || true
    [ $(ls -A "$SSH_CONFD_DIR" | wc -l) -eq 0 ] && echo $empty_dir_error && return 1 || true
}

###DOC: sshlist - List and connect to ssh aliases defined in ~/.ssh/config and ~/.ssh/conf.d
sshlist() {
    local ssh_check find_files_cmd ssh_config complete_ssh preview_cmd preview_tree_cmd
    [ "$1" = "init" ] && _ssh_init && return || true # init command
    ssh_check="$(_ssh_check)"
    [ ! -z "$ssh_check" ] && echo $ssh_check && return 1 || true
    preview_cmd='. $SHELL_FUNC_PATH; _ssh_info {} | bat --color=always --style=grid'
    preview_tree_cmd="tree -CF -L 3 -l $SSH_CONFD_DIR | bat --color=always --style=grid"
    find_files_cmd="find -L $SSH_CONFD_DIR -type f -name '*.conf' -print0 | sort -z"
    ssh_config=$(sh -c "$find_files_cmd" | xargs -0 -I{} sh -c "cat {};echo")$(
        echo
        cat "$SSH_USER_DIR/config"
    )
    # Parse ssh config: Get only first host alias, no wildcard config.
    complete_ssh=$(echo "$ssh_config" | grep -P '^Host ([^*]+)$' | sed 's/Host //' | awk '{ print $1 }')
    printf '%s\n' ${complete_ssh[@]} | fzf --border --info=inline --no-mouse \
        --preview="$preview_cmd; $preview_tree_cmd" | xargs -o -I{} ssh -tt {}
}

# Directory bookmarks

# Init bookmarks directory
_mark_init() {
    mkdir -p "$BOOKMARKS_DIR"
    echo "directory bookmarks initialized"
    return 0
}

###DOC: marklist - List directory bookmarks defined in ~/.bookmarks
marklist() {
    [ "$1" = "init" ] && _mark_init && return || true # init command
    local noexist_error="$BOOKMARKS_DIR doesn't exist. Run 'marklist init' first."
    [ ! -d "$BOOKMARKS_DIR" ] && echo "$noexist_error" && return 1 || true
    local preview_cmd="tree -CF -L 2 $BOOKMARKS_DIR/{}"
    local path_prefix_escaped="$(echo $BOOKMARKS_DIR | sed 's/\//\\\//g')\/" # with trailing slash
    mark=$(find $BOOKMARKS_DIR -type l | sed "s/$path_prefix_escaped//" \
        | fzf --no-mouse --preview "$preview_cmd" \
            --header="<Del> Delete, <Shift-Up|Down> Scroll preview, <Esc> Exit" \
            --bind "del:reload(rm $BOOKMARKS_DIR/{})")
    if [ -n "$mark" ]; then
        markgo "$mark"
    fi
}

###DOC: markadd - Add directory bookmark. Usage: markadd [source/directory/path] [bookmark-name].
markadd() {
    local dir_path bookmark_name
    [ -n "$1" ] && dir_path="$1" || dir_path="$(pwd)"
    [ -n "$2" ] && bookmark_name="$2" || bookmark_name="$(basename "$PWD")"
    ln -sf "$dir_path" "$BOOKMARKS_DIR/@$bookmark_name"
}

###DOC: markgo - Go to bookmark target directory. Usage: markgo <bookmark-name>.
markgo() {
    export CDPATH=".:$BOOKMARKS_DIR:/"
    [ -n "$1" ] && cd -P "$1" || false
}

# Kube tools
# https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/
# https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/
# TODO : kubectl config view --flatten > ~/.kube/config

# Check kubelist|kubeset directories and files
_kube_check() {
    local noexist_error empty_dir_error
    noexist_error="$KUBE_CLUSTERS_DIR doesn't exist. Run 'kubeset|kubelist init' first."
    empty_dir_error="$KUBE_CLUSTERS_DIR is empty. Add files first."
    [ ! -d "$KUBE_CLUSTERS_DIR" ] && echo "$noexist_error" && return 1 || true
    [ $(ls -A "$KUBE_CLUSTERS_DIR" | wc -l) -eq 0 ] && echo $empty_dir_error && return 1 || true
}

# Init kubelist|kubeset directories and files
_kube_init() {
    mkdir -p $KUBE_CLUSTERS_DIR
    echo "kube initialized"
    return 0
}

###DOC: kubeset - Set KUBECONFIG env with merging multiple kubeconfig files in ~/.kube/clusters/
kubeset() {
    [ "$1" = "init" ] && _kube_init && return || true # init command
    local kube_check="$(_kube_check)"
    [ ! -z "$kube_check" ] && echo $kube_check && return 1 || true
    export KUBECONFIG=$(find -L $KUBE_CLUSTERS_DIR -type f | sed ':a;N;s/\n/:/;ba')
}

###DOC: kubelist - Set KUBECONFIG env with single kubeconfig file in ~/.kube/clusters/
kubelist() {
    local kube_check path_prefix_escaped kubeconfig preview_cmd preview_tree_cmd
    [ "$1" = "init" ] && _kube_init && return || true # init command
    kube_check="$(_kube_check)"
    [ ! -z "$kube_check" ] && echo $kube_check && return 1 || true
    path_prefix_escaped="$(echo $KUBE_CLUSTERS_DIR | sed 's/\//\\\//g')\/" # with trailing slash
    preview_cmd="bat --style=numbers --color=always --line-range :500 $KUBE_CLUSTERS_DIR/{}"
    preview_tree_cmd="tree -CF -L 3 -l $KUBE_CLUSTERS_DIR | bat --color=always --style=grid"
    kubeconfig=$(find -L $KUBE_CLUSTERS_DIR -type f | sed "s/$path_prefix_escaped//" \
        | fzf --no-mouse --preview "$preview_cmd; $preview_tree_cmd")
    if [ ! -z "$kubeconfig" ]; then
        export KUBECONFIG="$KUBE_CLUSTERS_DIR/$kubeconfig"
    fi
}

###DOC: kubectx - List and switch k8s contexts
kubectx() {
    kubectl config get-contexts -o name | fzf | xargs kubectl config use-context
}

###DOC: kubens - List and switch k8s namespaces
kubens() {
    local ns=$(kubectl get namespace --no-headers=true -o custom-columns=NAME:.metadata.name | fzf)
    kubectl config set-context --current --namespace=$ns
}

# AWS tools

###DOC: awslist - Set AWS_PROFILE by parsing AWS named profiles in file ~/.aws/credentials
awslist() {
    local profile noexist_error="$AWS_CREDENTIALS_PATH doesn't exist. Create this file first."
    if [ ! -f "$AWS_CREDENTIALS_PATH" ] && [ ! -L "$AWS_CREDENTIALS_PATH" ]; then
        echo "$noexist_error" && return 1
    fi
    profile=$(awk '{ if ($1 ~ /^\[/) print $1 }' $AWS_CREDENTIALS_PATH | sed 's/[][]//g' | fzf)
    if [ ! -z "$profile" ]; then
        export AWS_PROFILE=$profile
    fi
}
